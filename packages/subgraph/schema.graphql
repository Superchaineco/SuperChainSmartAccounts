type EIP712DomainChanged @entity(immutable: true) {
  id: Bytes!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type OwnerAdded @entity(immutable: true) {
  id: Bytes!
  safe: Bytes! # address
  newOwner: Bytes! # address
  superChainId: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  superChainSmartAccount: SuperChainSmartAccount!
}

type OwnerPopulated @entity {
  id: Bytes!
  safe: Bytes! # address
  newOwner: Bytes! # address
  superChainId: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  superChainSmartAccount: SuperChainSmartAccount!
}

type OwnerPopulationRemoved @entity(immutable: true) {
  id: Bytes!
  safe: Bytes! # address
  owner: Bytes! # address
  superChainId: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  superChainSmartAccount: SuperChainSmartAccount!
}

type PointsIncremented @entity(immutable: true) {
  id: Bytes!
  recipient: Bytes! # address
  points: BigInt! # uint256
  levelUp: Boolean!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  superChainSmartAccount: SuperChainSmartAccount!
}

type SuperChainSmartAccount @entity {
  id: Bytes!
  safe: Bytes! # address
  initialOwner: Bytes! # address
  superChainId: String! # string
  noun_background: BigInt! # uint48
  noun_body: BigInt! # uint48
  noun_accessory: BigInt! # uint48
  noun_head: BigInt! # uint48
  noun_glasses: BigInt! # uint48
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  level: BigInt!
  points: BigInt!
  badges: [AccountBadge!]! @derivedFrom(field: "user") @orderBy(direction: asc)
  levels: [LevelClaim!]! @derivedFrom(field: "account")
}

type BadgeTier @entity {
  id: String!
  points: BigInt!
  tier: BigInt! @orderBy(direction: asc)
  badge: Badge! # Relación con Badge
  uri: String! # string
  perk: Perk # Relación opcional con Perk (referencia por hash)
}

type Badge @entity {
  id: String!
  badgeId: BigInt!
  uri: String!
  badgeTiers: [BadgeTier!]!
    @derivedFrom(field: "badge")
    @orderBy(direction: asc)
  perks: [Perk!]! @derivedFrom(field: "badge")
}

type Perk @entity {
  id: Bytes! # keccak256(abi.encodePacked(badgeId, tier)).toHexString()
  badgeId: BigInt!
  tier: BigInt!
  badge: Badge! # Relación con Badge
  badgeTier: BadgeTier # Relación con BadgeTier (opcional cuando tier=0)
  token: Bytes! # address del token del premio
  amount: BigInt! # cantidad del premio
  maxClaims: BigInt! # máximo número de claims permitidos
  totalClaims: BigInt! # número actual de claims
  isCompleted: Boolean! # si se alcanzó el máximo de claims
  redemptions: [PerkRedemption!]! @derivedFrom(field: "perk")
  userClaims: [UserPerkClaim!]! @derivedFrom(field: "perk")
}

type AccountBadge @entity {
  id: Bytes!
  user: SuperChainSmartAccount! # Relación con SuperChainSmartAccount
  badge: Badge! # Relación con Badge
  tier: BigInt!
  points: BigInt! # uint256
  perkClaims: [UserPerkClaim!]! @derivedFrom(field: "accountBadge")
}

type TierTresholds @entity {
  id: ID!
  tresholds: [BigInt!]!
}

type LevelClaim @entity {
  id: Bytes! # Una combinación única de usuario y nivel
  account: SuperChainSmartAccount!
  level: BigInt!
  timestamp: BigInt!
}

type PerkRedemption @entity(immutable: true) {
  id: Bytes! # transaction hash + log index
  perk: Perk! # Relación directa con Perk
  redeemer: Bytes! # address
  token: Bytes! # address
  amount: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserPerkClaim @entity {
  id: String! # user-perkId
  user: Bytes! # address
  perk: Perk! # Relación directa con Perk
  accountBadge: AccountBadge # Relación opcional con AccountBadge
  isClaimed: Boolean!
  claimedAt: BigInt # timestamp cuando se reclamó
  transactionHash: Bytes # hash de la transacción de claim
}

type Meta @entity {
  id: String!
  count: BigInt!
}
